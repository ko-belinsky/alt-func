#Обновление системы с более информативным выводом информации.
dist-upgrade() {
    # Функция для обработки прерывания
    handle_interrupt() {
        echo -e "\033[31mСогласен, стрёмно это всё...\033[0m"
        exit 1
    }

    # Устанавливаем обработчик SIGINT
    trap handle_interrupt SIGINT
    
#Проверяем права пользователя
    sudo -v
    
#Начинаем процесс обновления    
    echo ":: Синхронизация, ожидайте..."
    sudo apt-get update >/dev/null 2>&1

    # Массив для склонения слова "пакет"
    pkg_word=("пакет" "пакета" "пакетов")

    echo ":: Формируется список..."
    updates=$(sudo apt-get dist-upgrade -s | grep -E "^Inst|^Remv")

    if [ -z "$updates" ]; then
        echo -e ":: \033[32mНет доступных обновлений.\033[0m"
        return
    fi

    # Инициализируем переменные
    upgrade_count=0
    install_count=0
    remove_count=0
    upgrade_packages=()
    install_packages=()
    remove_packages=()

    # Обрабатываем каждую строку
    while IFS= read -r line; do
        # Удаляем всё после закрывающей круглой скобки
        line=$(echo "$line" | sed 's/).*//')

        # Извлекаем название пакета
        pkg_name=$(echo "$line" | awk '{print $2}')

        # Обрезаем название пакета до 37 символов и добавляем ... только если оно было обрезано
        if [ ${#pkg_name} -gt 37 ]; then
            pkg_name=$(echo "$pkg_name" | cut -c -37)
            pkg_name="$pkg_name..."
        fi

        # Обработка пакетов для удаления
        if echo "$line" | grep -q "^Remv"; then
            remove_count=$((remove_count + 1))
            version=$(echo "$line" | grep -oP '\(\K[^)]+' | sed 's/\(:sisyphus\|:p11\).*//')
            remove_packages+=("$pkg_name $version")
            continue
        fi

        # Извлекаем текущую версию (если есть)
        current_version=$(echo "$line" | grep -oP '\[\K[^]]+')
        if [ -n "$current_version" ]; then
            # Обрезаем версию после :sisyphus или первого :/@
            current_version=$(echo "$current_version" | sed 's/\(:sisyphus\|:p11\).*//')
        fi

        # Извлекаем новую версию
        new_version=$(echo "$line" | grep -oP '\(\K[^)]+')
        if [ -n "$new_version" ]; then
            # Обрезаем версию после :sisyphus или первого :/@
            new_version=$(echo "$new_version" | sed 's/\(:sisyphus\|:p11\).*//')
        fi

        # Определяем тип пакета (обновление или установка)
        if [ -n "$current_version" ]; then
            upgrade_count=$((upgrade_count + 1))
            upgrade_packages+=("$pkg_name $current_version $new_version")
        else
            install_count=$((install_count + 1))
            install_packages+=("$pkg_name $new_version")
        fi
    done <<< "$updates"

    # Функция для склонения
    plural_form() {
        num=$1
        case $num in
            *1[0-9]) idx=2;;
            *1)      idx=0;;
            *[2-4])  idx=1;;
            *)       idx=2;;
        esac
        echo "${pkg_word[$idx]}"
    }

    # Выводим заголовок с правильным склонением
    echo -e ":: Найдено обновлений: \033[1;33m$upgrade_count\033[0m | \
Установится: \033[1;32m$install_count\033[0m $(plural_form $install_count), \
Удалится: \033[1;31m$remove_count\033[0m $(plural_form $remove_count)"
    echo "----------------------------------------------------------------------------------"
    echo -e "\033[34mПакет                                    Текущая версия       Новая версия\033[0m"
    echo "----------------------------------------------------------------------------------"

    # Выводим обновляемые пакеты
    for pkg in "${upgrade_packages[@]}"; do
        pkg_name=$(echo "$pkg" | awk '{print $1}')
        current_version=$(echo "$pkg" | awk '{print $2}')
        new_version=$(echo "$pkg" | awk '{print $3}')
        printf "\033[33m%-40s\033[0m \033[0m%-20s\033[0m \033[97m%-20s\033[0m\n" "$pkg_name" "$current_version" "$new_version"
    done

    # Выводим устанавливаемые пакеты
    for pkg in "${install_packages[@]}"; do
        pkg_name=$(echo "$pkg" | awk '{print $1}')
        new_version=$(echo "$pkg" | awk '{print $2}')
        printf "\033[32m%-40s\033[0m \033[0m%-20s\033[0m \033[97m%-20s\033[0m\n" "$pkg_name" "" "$new_version"
    done

    # Выводим удаляемые пакеты
    for pkg in "${remove_packages[@]}"; do
        pkg_name=$(echo "$pkg" | awk '{print $1}')
        version=$(echo "$pkg" | awk '{print $2}')
        printf "\033[31m%-40s\033[0m \033[0m%-20s\033[0m \033[97m%-20s\033[0m\n" "$pkg_name" "$version" ""
    done

    echo "----------------------------------------------------------------------------------"

    # Спрашиваем, выполнять ли обновление
    if [[ "$1" != "-y" ]]; then
        read -p ":: Надеюсь, система после этого не отрыгнет... пробуем? (y/n): " choice
        if [ "$choice" != "y" ]; then
            echo -e ":: \033[31mСогласен, стрёмно это всё...\033[0m"
            return
        fi
    fi

    echo ":: Ну, погнали, помолясь..."
    sudo apt-get dist-upgrade -y
    echo -e ":: \033[32mНе знаю, что из этого вышло. Проверяй!\033[0m"
}

# Цветной вывод поиска пакетов в репозитории
rs() {
    show_usage() { echo "Напишите, что нужно найти..."; return 1; }
    get_package_versions() { local package_names="$1"; apt-cache policy $package_names; }
    animate_waiting() {
        local text="$1"; local frames=("   " ".  " ".. " "..." " .." "  .");
        while true; do for frame in "${frames[@]}"; do echo -ne "\r$text $frame"; sleep 0.2; done; done
    }
    check_installed() { local package_name="$1"; rpm -q --queryformat '%{NAME}' "$package_name" &>/dev/null; return $?; }
    print_results() {
        local results="$1"; local verbose="$2"; local policy_output="$3"; local words=("${@:4}");
        echo "$results" | while read -r line; do
            local package_name=$(echo "$line" | awk '{print $1}'); local description=$(echo "$line" | awk '{$1=""; print $0}' | sed 's/^ *//');
            if $verbose; then
                local candidate_version=$(echo "$policy_output" | awk -v pkg="$package_name" '$0 ~ pkg ":" { found=1 } found && /Кандидат:/ { print $2; exit }');
                candidate_version=$(echo "$candidate_version" | sed 's/\(:sisyphus\|:p11\).*//'); echo -en "\033[33m$package_name\033[0m \033[32m($candidate_version)\033[0m";
            else echo -en "\033[33m$package_name\033[0m"; fi
            if check_installed "$package_name"; then echo -en " \033[0;95m[Установлен]\033[0m"; fi
            for word in "${words[@]}"; do description=$(echo "$description" | awk -v word="$word" 'BEGIN {IGNORECASE=1} { gsub(word, "\033[1;37m&\033[0m", $0); print }'); done
            echo -e " $description"
        done
    }
    local original_args="$*"; if [ -z "$original_args" ] || [[ "$original_args" =~ ^[[:space:]]*$ ]]; then show_usage; return 1; fi
    local verbose=false; local exact_match=false; while [[ $# -gt 0 ]]; do case "$1" in -v|--verbose) verbose=true; shift ;; -e|--exact) exact_match=true; shift ;; *) break ;; esac; done
    local query="$*"; if [ -z "$query" ] || [[ "$query" =~ ^[[:space:]]*$ ]]; then show_usage; return 1; fi
    local words=($query); local regex=""; for word in "${words[@]}"; do regex+="(?=.*${word})"; done
    local grep_options="-P"; if ! $exact_match; then grep_options+="i"; fi
    local results=$(apt-cache search . | grep $grep_options "$regex"); if [ -z "$results" ]; then echo -e "\nПо вашему запросу ничего не найдено..."; return 0; fi
    local count=$(echo "$results" | wc -l); local found_words=("Найден всего" "Найдено" "Найдено"); local package_words=("пакетик" "пакетика" "пакетиков"); local suitable_words=("подходящий" "подходящих" "подходящих")
    local index; if [ "$count" -eq 1 ]; then index=0; elif [ "$count" -ge 2 ] && [ "$count" -le 4 ]; then index=1; else index=2; fi
    echo -e "\n${found_words[$index]} $count ${suitable_words[$index]} ${package_words[$index]}:\n"
    if $verbose; then
        set +m; echo -ne "\e[?25l"; { animate_waiting "получение версий" & } 2>/dev/null; local animation_pid=$!; disown $animation_pid 2>/dev/null
        local package_names=$(echo "$results" | awk '{print $1}'); local policy_output=$(get_package_versions "$package_names")
        kill $animation_pid 2>/dev/null; wait $animation_pid 2>/dev/null; echo -ne "\r\033[K"; echo -ne "\e[?25h"; set -m
    else local policy_output=""; fi
    print_results "$results" "$verbose" "$policy_output" "${words[@]}"
}



# Поиск установленных пакетов с цветным выводом
isv() {
    rpm -qa | grep -i "$1" | while read -r pkg; do
        # Получаем данные и выводим их в одну строку
        echo -e "\e[33m$(rpm -q --queryformat '%{NAME}\n' "$pkg")\e[0m \e[32m$(rpm -q --queryformat '%{VERSION}-%{RELEASE}\n' "$pkg")\e[0m \e[95m[Установлен:\e[0m \e[97m$(rpm -q --queryformat '%{INSTALLTIME:date}\n' "$pkg")\e[0m\e[95m]\e[0m - $(rpm -q --queryformat '%{SUMMARY}\n' "$pkg")"
    done
}

# Автодополнение для rs и rsv
_rs_completion() {
    local cur=${COMP_WORDS[COMP_CWORD]}
    local cache_dir="/tmp/apt-cache"
    local cache_file="$cache_dir/pkglist"
    
    # Создаем директорию для кэша если её нет
    mkdir -p "$cache_dir"

    # Проверяем время последнего обновления репозитория (МСК)
    local msk_time=$(TZ=Europe/Moscow date +%H)
    local cache_age=0
    
    if [ -f "$cache_file" ]; then
        cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file")))
    fi

    # Обновляем кэш если:
    # 1. Файл не существует
    # 2. Файл старше 24 часов
    # 3. Сейчас ночь по МСК (между 00:00 и 06:00) и кэш старше 1 часа
    if [ ! -f "$cache_file" ] || [ $cache_age -gt 86400 ] || \
       ([ $msk_time -ge 0 ] && [ $msk_time -lt 6 ] && [ $cache_age -gt 3600 ]); then
        apt-cache pkgnames > "$cache_file" 2>/dev/null
    fi

    COMPREPLY=($(grep -i "^$cur" "$cache_file" 2>/dev/null))
    return 0
}

# Автодополнение для isv
_isv_completion() {
    local cur=${COMP_WORDS[COMP_CWORD]}
    COMPREPLY=($(rpm -qa --qf "%{NAME}\n" | grep -i "^$cur" 2>/dev/null))
    return 0
}

# Регистрация автодополнения
complete -F _rs_completion rs rsv
complete -F _isv_completion isv

homesize() {
    # Получаем данные о занятом месте в /home
    home_info=$(df -h /home | tail -1)
    total=$(echo "$home_info" | awk '{print $2}')
    used=$(echo "$home_info" | awk '{print $3}')
    free=$(echo "$home_info" | awk '{print $4}')
    used_percent=$(echo "$home_info" | awk '{print $5}')

    # ASCII-заголовок с информацией
    echo -e "\033[1;35m========================================================\033[0m"
    echo -e "\033[1;32m◉ Всего: $total    ◉ Занято: $used ($used_percent)    ◉ Свободно: $free\033[0m"
    echo -e "\033[1;35m--------------------------------------------------------\033[0m\n"

    # Вывод размеров папок
    find ~ -maxdepth 1 -type d ! -name "$(basename ~)" -exec du -sh {} + 2>/dev/null \
    | awk '{printf "%s\t%s\n", $1, $2}' \
    | sort -rh \
    | awk -F'\t' '{printf "\033[1;33m%-50s\033[0m \033[1;32m%s\033[0m\n", $2, $1}'
}
